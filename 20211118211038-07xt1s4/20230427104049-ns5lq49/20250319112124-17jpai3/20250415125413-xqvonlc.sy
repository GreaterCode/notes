{
	"ID": "20250415125413-xqvonlc",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20250415125413-xqvonlc",
		"title": "计算虚拟化2——内存虚拟化",
		"type": "doc",
		"updated": "20250415125413"
	},
	"Children": [
		{
			"ID": "20250415125413-wpxq79u",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20250415125413-wpxq79u",
				"updated": "20250415125413"
			}
		},
		{
			"ID": "20250415125413-e0tck2w",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20250415125413-e0tck2w",
				"updated": "20250416011731"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. 物理机内存访问过程"
				}
			]
		},
		{
			"ID": "20250415125413-czlkkfw",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20250415125413-czlkkfw",
				"updated": "20250416011216"
			},
			"Children": [
				{
					"ID": "20250415125756-pzs1a5e",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20250415125756-pzs1a5e",
						"updated": "20250416011216"
					},
					"Children": [
						{
							"ID": "20250415125756-xj0zagi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250415125756-xj0zagi",
								"updated": "20250415125756"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "内存的基本知识"
								}
							]
						},
						{
							"ID": "20250415125801-8zuiqao",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250415125801-8zuiqao",
								"updated": "20250416011216"
							},
							"Children": [
								{
									"ID": "20250416011216-xzdbc1c",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250416011216-xzdbc1c",
										"style": "--en-bullet-line-height: 38px;",
										"updated": "20250416011216"
									},
									"Children": [
										{
											"ID": "20250416011216-axim6s8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250416011216-axim6s8",
												"updated": "20250416011216"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "内存都是从"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://so.csdn.net/so/search?q=%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80\u0026amp;spm=1001.2101.3001.7020",
													"TextMarkTextContent": "物理地址"
												},
												{
													"Type": "NodeText",
													"Data": "0开始的，n结束"
												}
											]
										}
									]
								},
								{
									"ID": "20250416011221-n2yu9by",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250416011221-n2yu9by",
										"style": "--en-bullet-line-height: 76px;",
										"updated": "20250416011221"
									},
									"Children": [
										{
											"ID": "20250416011221-h2d3h8i",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250416011221-h2d3h8i",
												"updated": "20250416011227"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "内存都是连续的\n"
												}
											]
										}
									]
								},
								{
									"ID": "20250416011229-cl3mhcs",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250416011229-cl3mhcs",
										"updated": "20250416011229"
									},
									"Children": [
										{
											"ID": "20250416011229-r69ml7u",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250416011229-r69ml7u",
												"updated": "20250416011229"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "MMU（Memory Management Unit）内存管理单元，主要功能为将内存"
												},
												{
													"Type": "NodeTextMark",
													"TextMarkType": "a",
													"TextMarkAHref": "https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80\u0026amp;spm=1001.2101.3001.7020",
													"TextMarkTextContent": "虚拟地址"
												},
												{
													"Type": "NodeText",
													"Data": "到物理地址的转换、内存保护、中央告诉缓存的控制等"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-ykuag3k",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-ykuag3k",
				"updated": "20250416011731"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.1 虚拟地址VA和物理地址PA概念"
				}
			]
		},
		{
			"ID": "20250415125413-ztgf639",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20250415125413-ztgf639",
				"updated": "20250416011731"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20250415125413-31yfut9",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-31yfut9",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "为什么提出虚拟地址VA"
						}
					]
				},
				{
					"ID": "20250415125413-fv80yrn",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-fv80yrn",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "我们知道一个服务器的物理内存是固定的，从0开始，到n结束；当有多个应用程序要使用内存时，每个应用程序都认为自己使用的内存地址是从0开始，到x结束（x≤n），此时某个进程的内存区就可能会被别的进程覆盖；为了解决此问题就提出了虚拟内存的概念，也就是虚拟内存地址VA的概念（应用程序通过此地址无法直接访问内存），通过MMU内存管理单元来把每个应用程序使用的VA虚拟地址转为具体的对应的物理内存地址PA"
						}
					]
				},
				{
					"ID": "20250415125413-r1a1857",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-r1a1857",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "虚拟地址VA和物理地址PA的转换"
						}
					]
				},
				{
					"ID": "20250415125413-8q1c2o2",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-8q1c2o2",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "虚拟地址VA由虚拟页面号VPN和虚拟地址偏移VA Offset组成；物理地址PA由物理页帧号PFN和物理地址偏移PA Offset组成（通常PA Offset等于VA Offset）"
						}
					]
				},
				{
					"ID": "20250415125413-fm1ccjs",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-fm1ccjs",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "当虚拟地址VA转为物理地址时，需要将VPN转为PFN，然后在加上VA Offset（即 PA=PFN+VA Offset）"
						}
					]
				},
				{
					"ID": "20250415125413-mgndpdp",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-mgndpdp",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://i-blog.csdnimg.cn/blog_migrate/1b72ee897da548988fd1727877e92e37.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"ID": "20250415125413-fsyox8p",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-fsyox8p",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "VA和PA地址转换的大致工作原理如下"
						}
					]
				},
				{
					"ID": "20250415125413-oq1eqto",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-oq1eqto",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "实际上应用程序在往内存中读写数据时，需要先将请求发往CPU，再由CPU发往内存"
						}
					]
				},
				{
					"ID": "20250415125413-82yezdy",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-82yezdy",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "所以应用程序将自己需要访问的虚拟内存地址VA发往CPU，CPU将VA虚拟地址发给MMU"
						}
					]
				},
				{
					"ID": "20250415125413-r1oodfq",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-r1oodfq",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "，MMU通过"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "a",
							"TextMarkAHref": "https://so.csdn.net/so/search?q=%E6%98%A0%E5%B0%84%E8%A1%A8\u0026amp;spm=1001.2101.3001.7020",
							"TextMarkTextContent": "映射表"
						},
						{
							"Type": "NodeText",
							"Data": "将VA虚拟地址转为PA物理内存地址，然后交给内存完成内存的读写"
						}
					]
				},
				{
					"ID": "20250415125413-x6b4386",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-x6b4386",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://i-blog.csdnimg.cn/blog_migrate/fd2ac8e6c030558007bd3d29e9bbf3bd.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"ID": "20250415125413-ohw0hl0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-ohw0hl0",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "补充：程序的执行过程"
						}
					]
				},
				{
					"ID": "20250415125413-5bvbr4s",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-5bvbr4s",
						"updated": "20250416011731"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"Properties": {
								"style": "background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);"
							},
							"TextMarkType": "text",
							"TextMarkTextContent": "在用户执行程序文件时通过系统内核将其调用到硬件的内存中去，然后由内存交给CPU进行处理；CPU处理完成后将结果返回到内存，内存再通过系统内核输出给用户的输出设备"
						},
						{
							"Type": "NodeKramdownSpanIAL",
							"Data": "{: style=\"background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);\"}"
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-14d1s43",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-14d1s43",
				"updated": "20250416011424"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1.2 MUU实现VA到PA所使用的映射表"
				}
			]
		},
		{
			"ID": "20250415125413-6hj5l5s",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20250415125413-6hj5l5s",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20250415125413-81d78dl",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-81d78dl",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "MMU将VA转为PA的两种映射表：页表（慢表）、TLB传输后备缓冲器（快表）"
						}
					]
				},
				{
					"ID": "20250415125413-8ne6gyk",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-8ne6gyk",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "页表（慢表）基本概念"
						}
					]
				},
				{
					"ID": "20250415125413-3nxrwcs",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-3nxrwcs",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "MMU没有自己的存储空间，所以最开始映射表存储在内存中，名字叫页表"
						}
					]
				},
				{
					"ID": "20250415125413-kxsk0b5",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-kxsk0b5",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "MMU如何知道页表在内存的具体地址呢？"
						}
					]
				},
				{
					"ID": "20250415125413-i4wqb8z",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-i4wqb8z",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "通常CPU会提供一个页表基址寄存器给操作系统使用，用于给MMU指示页表的基地址（不同处理器架构对应的寄存器不一样，x86的寄存器为CR3、ARM-v8的寄存器为TTBR、RISC-V的寄存区为SATP）；寄存器存储了第一级页表的基地址，由于在实际使用中都是使用多级页表来存储虚拟地址和物理地址的映射关系，所以需要寄存器找到第一级页表的基地址，然后依次查找后续级别的页表知道找到VA对应的真正的物理内存地址"
						}
					]
				},
				{
					"ID": "20250415125413-tztxyxo",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-tztxyxo",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "不同多级页表涉及的表项"
						}
					]
				},
				{
					"ID": "20250415125413-kz49agh",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-kz49agh",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "二级页表"
						}
					]
				},
				{
					"ID": "20250415125413-1816kgr",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-1816kgr",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "分为页全局目录PGD（page global directory）和页表入口PTE（page table entry）"
						}
					]
				},
				{
					"ID": "20250415125413-0lprg90",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-0lprg90",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "其中PGD来存储下一级页表的基地址，PTE来存储真正的物理地址"
						}
					]
				},
				{
					"ID": "20250415125413-l8p56yb",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-l8p56yb",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "共有PGD、PTE二级目录"
						}
					]
				},
				{
					"ID": "20250415125413-szni1ye",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-szni1ye",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "三级页表"
						}
					]
				},
				{
					"ID": "20250415125413-mic0kj0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-mic0kj0",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "在PGD和PTE之间新加了页中间目录PMD（page middle directory）"
						}
					]
				},
				{
					"ID": "20250415125413-d4ynlvk",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-d4ynlvk",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "共有PGD、PMD、PTE三级目录"
						}
					]
				},
				{
					"ID": "20250415125413-7akcvea",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-7akcvea",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "四级页表"
						}
					]
				},
				{
					"ID": "20250415125413-qg08ngf",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-qg08ngf",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "在PGD和PMD之间新增了页上级目录PUD（page upper directory）"
						}
					]
				},
				{
					"ID": "20250415125413-c0awa0m",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-c0awa0m",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "共有PGD、PUD、PMD、PTE四级目录"
						}
					]
				},
				{
					"ID": "20250415125413-q8bdzx9",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-q8bdzx9",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://i-blog.csdnimg.cn/blog_migrate/82fb23f2794b05214353191c36f62b34.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"ID": "20250415125413-l6ekc7z",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-l6ekc7z",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "常见系统使用多级页表的类型"
						}
					]
				},
				{
					"ID": "20250415125413-azs72cp",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-azs72cp",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "未开启PAE物理地址扩展的32位系统只使用二级页表；开启PAE物理地址扩展的32位系统使用三级页表；64位系统使用四级页表或三级页表"
						}
					]
				},
				{
					"ID": "20250415125413-slhsp8z",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-slhsp8z",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "具体使用多少级页表、虚拟地址、物理地址等的格式与是32位系统还是64位系统有关、也与处理器的架构有关；但是MMU管理的工作原理都是一致的，不管是二级页表、三级还是四级，都是通过第一级找到第二级，第二级找到第三级等，最终找到其它物理地址"
						}
					]
				},
				{
					"ID": "20250415125413-z7o8ikj",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-z7o8ikj",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "使用三级页表的工作原理"
						}
					]
				},
				{
					"ID": "20250415125413-1su128c",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-1su128c",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "由于使用三级页表来存放VA与PA之间的关系，此时VA地址也被分为4部分VPN1、VPN2、VPN3、VA Offset"
						}
					]
				},
				{
					"ID": "20250415125413-ia9risp",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-ia9risp",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "应用程序将VA发给CPU，CPU将VA发给MMU，MMU访问页表基址寄存器，得到一级页表PGD的基地址，再结合虚拟地址中的VPN1（PGD index）找到下一级页表PMD的基地址；得到了PMD的基地址，再结合虚拟地址中的VPN2（PMD index）得到再下一级PTE的基地址，结合虚拟地址中的VPN3（PTE index）的到最终的PFN，然后通过PFN+VA offset得到真实的物理地址，然后MMU将VA转为PA，最后通过PA地址访问内存"
						}
					]
				},
				{
					"ID": "20250415125413-wh47p7e",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-wh47p7e",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "CPU→MMU→寄存器→读取内存中的页表→MMU将VA转为PA→内存（整个流程访问了两次内存）"
						}
					]
				},
				{
					"ID": "20250415125413-mj88dhy",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-mj88dhy",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://i-blog.csdnimg.cn/blog_migrate/c11209c8be939a5d321aa939936f7be1.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"ID": "20250415125413-ytnjd8u",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-ytnjd8u",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "TLB传输后备缓冲器（快表）"
						}
					]
				},
				{
					"ID": "20250415125413-w72xo5u",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-w72xo5u",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "TLB存放在CPU缓存中（CPU缓存的速率高于内存），并且能够直接通过VA的VPN来获取到PA地址的PFN，进而获得PA地址"
						}
					]
				},
				{
					"ID": "20250415125413-pse665i",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-pse665i",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "TLB如何通过VA找到PA地址"
						}
					]
				},
				{
					"ID": "20250415125413-pm0t9sp",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-pm0t9sp",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "TLB表根据虚拟地址VA的高20位（此20位是针对x86架构的，不同架构的值不同）来查找表项，找对对应的物理地址PA"
						}
					]
				},
				{
					"ID": "20250415125413-85hbgx5",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-85hbgx5",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "TLB工作流程"
						}
					]
				},
				{
					"ID": "20250415125413-161y1zq",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-161y1zq",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "应用程序将VA地址发给CPU，CPU将VA发给MMU，MMU将存放在CPU缓存的TLB读取出来，然后MMU将VA转为PA，最后通过PA地址访问内存"
						}
					]
				},
				{
					"ID": "20250415125413-kpm6zmd",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-kpm6zmd",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "CPU→MMU→读取CPU缓存中的TLB表→MMU将VA转为PA→内存"
						}
					]
				},
				{
					"ID": "20250415125413-xu3epne",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-xu3epne",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "有些VA地址在TLB中没有映射怎么办？"
						}
					]
				},
				{
					"ID": "20250415125413-giu0fc0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-giu0fc0",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "根据VA的高20位地址，在TLB中查找对应的PA地址，如果没有对应表项就返回TLB Miss，此时MMU就去读取内存的页表，通过页表来实现VA到PA的转换"
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-6c0iliw",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20250415125413-6c0iliw",
				"updated": "20250415125413"
			}
		},
		{
			"ID": "20250415125413-smrxcuc",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20250415125413-smrxcuc",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2. 内存虚拟化类型"
				}
			]
		},
		{
			"ID": "20250415125413-t7fv3cb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-t7fv3cb",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "虚拟化架构知识："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://blog.csdn.net/m0_49864110/article/details/134151350?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22134151350%22%2C%22source%22%3A%22m0_49864110%22%7D",
					"TextMarkATitle": "虚拟化的基础知识-CSDN博客",
					"TextMarkTextContent": "虚拟化的基础知识-CSDN博客"
				}
			]
		},
		{
			"ID": "20250415125413-cjgowmq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-cjgowmq",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 内存半虚拟化主要是Xen厂商使用，此处不做介绍"
				}
			]
		},
		{
			"ID": "20250415125413-oivs375",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-oivs375",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "虚拟机访问物理内存的流程"
				}
			]
		},
		{
			"ID": "20250415125413-08dzi01",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-08dzi01",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://i-blog.csdnimg.cn/blog_migrate/310f9de64f0e12d922026c95a08d16bd.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20250415125413-t17yige",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-t17yige",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "虚拟机内存虚拟化的核心"
				}
			]
		},
		{
			"ID": "20250415125413-zf3slhn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-zf3slhn",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 虚拟机的内存虚拟化类似于物理机的虚拟内存，虚拟机的内存虚拟化通过引入一层新的地址空间（GPA），使得虚拟机以为自己运行在真实的物理地址中，实际上它是通过VMM访问真实的物理地址的"
				}
			]
		},
		{
			"ID": "20250415125413-r7nvmx9",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-r7nvmx9",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.1 内存软件辅助虚拟化"
				}
			]
		},
		{
			"ID": "20250415125413-x0061i7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-x0061i7",
				"updated": "20250416014252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "常用的软件辅助全虚拟化通过"
				},
				{
					"Type": "NodeTextMark",
					"Properties": {
						"style": "background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);"
					},
					"TextMarkType": "text",
					"TextMarkTextContent": "“影子页表"
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);\"}"
				},
				{
					"Type": "NodeText",
					"Data": "（shadow page table）”技术来实现"
				}
			]
		},
		{
			"ID": "20250415125413-4o95318",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20250415125413-4o95318",
				"updated": "20250416014310"
			},
			"Children": [
				{
					"ID": "20250416014310-6re51zd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20250416014310-6re51zd",
						"updated": "20250416014310"
					},
					"Children": [
						{
							"ID": "20250416014310-c7iq4yb",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250416014310-c7iq4yb",
								"updated": "20250416014310"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "虚拟机设计的每个映射表的作用"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-2y2gx5e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-2y2gx5e",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虚拟机的页表/TLB表维护GVA到虚拟机物理地址GPA的映射关系"
				}
			]
		},
		{
			"ID": "20250415125413-0mrvtgd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-0mrvtgd",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "VMM定义的映射表维护GPA到HVA的映射表"
				}
			]
		},
		{
			"ID": "20250415125413-bmhvsjk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-bmhvsjk",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "物理机的页表/TLB表维护HVA到HPA的映射表"
				}
			]
		},
		{
			"ID": "20250415125413-bo5d6lp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-bo5d6lp",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "VMM的影子页表维护GVA到HPA的映射表（影子页表由VMM维护）"
				}
			]
		},
		{
			"ID": "20250415125413-sh1xrxt",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20250415125413-sh1xrxt",
				"updated": "20250416014315"
			},
			"Children": [
				{
					"ID": "20250416014315-u0l9iwf",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20250416014315-u0l9iwf",
						"updated": "20250416014315"
					},
					"Children": [
						{
							"ID": "20250416014315-sr9slyc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250416014315-sr9slyc",
								"updated": "20250416014315"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "影子映射表的作用"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-zltg0z2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-zltg0z2",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "\tVMM为每个虚拟机都维护一个影子页表，影子页表维护GVA到HPA的映射表，简化了地址转换的过程（实现了三表合一），实现了虚拟机的虚拟内存地址GVA到物理机的真实内存地址HPA的直接映射"
				}
			]
		},
		{
			"ID": "20250415125413-yry0ktv",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20250415125413-yry0ktv",
				"updated": "20250416014322"
			},
			"Children": [
				{
					"ID": "20250416014322-it85b6c",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20250416014322-it85b6c",
						"updated": "20250416014322"
					},
					"Children": [
						{
							"ID": "20250416014322-tjv8z0i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250416014322-tjv8z0i",
								"updated": "20250416014322"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "具体工作原理"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-j7t3nib",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-j7t3nib",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当虚拟机通过虚拟机CR3寄存器来获取到自己虚拟机的页表或获取TLB表时，都会被VMM捕获，通过影子页表直接将GVA转为HPA，完成内存的访问"
				}
			]
		},
		{
			"ID": "20250415125413-ctkq8f5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-ctkq8f5",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果影子页表没有相应的GVP表项如何做"
				}
			]
		},
		{
			"ID": "20250415125413-jevluab",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-jevluab",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虚拟机的应用程序访问内存，CPU将GVA地址发给虚拟机的MMU，虚拟机的MMU通过页表或TLB表得到GPA；然后再通过VMM查找GPA对应的HVA，最后通过物理主机的页表或TLB表查HVA对应的HPA（如果没有HPA则为HVA分配对应的HPA），最终得到GVA对应的HPA关系，然后将其对应关系填充到影子页表"
				}
			]
		},
		{
			"ID": "20250415125413-4h1xrjr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-4h1xrjr",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "VMM如何感知到虚拟机对自己的页表做出了一些更改"
				}
			]
		},
		{
			"ID": "20250415125413-ke0gu96",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-ke0gu96",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "VMM将虚拟机对应影子页表的物理内存区域标记为只读状态，当虚拟机想要更改自己的页表时，就会对该物理内存区域做出更改的操作，此时就会抛出CPU的异常，触发一个VM Exit，这个时候就退出到VMM中，VMM就知道了虚拟机在更改页表"
				}
			]
		},
		{
			"ID": "20250415125413-rsfc32c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-rsfc32c",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此时VMM代替虚拟机操作系统修改虚拟机页表，然后更新自身的影子页表中GVA到HPA的映射关系"
				}
			]
		},
		{
			"ID": "20250415125413-910m6u3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-910m6u3",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://i-blog.csdnimg.cn/blog_migrate/b9992167def66e88b652dc6e13960c11.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20250415125413-h1tp8om",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-h1tp8om",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "存在的问题"
				}
			]
		},
		{
			"ID": "20250415125413-yizjbc9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-yizjbc9",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "每次触发VM exit的话开销很高"
				}
			]
		},
		{
			"ID": "20250415125413-y9vn84h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-y9vn84h",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "VMM承担太多影子页表的维护工作"
				}
			]
		},
		{
			"ID": "20250415125413-5riyo3u",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-5riyo3u",
				"updated": "20250415130851"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2.3 内存硬件辅助虚拟化"
				}
			]
		},
		{
			"ID": "20250415125413-vadqa7z",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20250415125413-vadqa7z",
				"updated": "20250415130718"
			},
			"Children": [
				{
					"ID": "20250415130714-8h07crz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20250415130714-8h07crz",
						"updated": "20250415130718"
					},
					"Children": [
						{
							"ID": "20250415130714-l34g55a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250415130714-l34g55a",
								"updated": "20250415130714"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "常见的内存硬件虚拟化技术"
								}
							]
						},
						{
							"ID": "20250415130716-ldsojp5",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20250415130716-ldsojp5",
								"updated": "20250415130718"
							},
							"Children": [
								{
									"ID": "20250415130718-b8dfkmp",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250415130718-b8dfkmp",
										"style": "--en-bullet-line-height: 38px;",
										"updated": "20250415130718"
									},
									"Children": [
										{
											"ID": "20250415130718-iitwx0w",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250415130718-iitwx0w",
												"updated": "20250415130718"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "Inter的EPT（Extend Page Table）扩展页表技术"
												}
											]
										}
									]
								},
								{
									"ID": "20250415130720-djyxnxo",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20250415130720-djyxnxo",
										"updated": "20250415130720"
									},
									"Children": [
										{
											"ID": "20250415130720-xsbjpqq",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20250415130720-xsbjpqq",
												"updated": "20250415130720"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "AMD的NPT（Nested Page Tables）嵌套页表技术"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-cbl583m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-cbl583m",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "\t两者细节方面有所不同，但是设计理念完全一致，把影子页表中依靠软件实现的过程改为硬件实现（GVP到GPA的转换没有变化，只是GPA到HPA的转化是由硬件来完成）"
				}
			]
		},
		{
			"ID": "20250415125413-k3mdbo0",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20250415125413-k3mdbo0",
				"updated": "20250415130851"
			},
			"Children": [
				{
					"ID": "20250415130851-owyfwcb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20250415130851-owyfwcb",
						"updated": "20250415130851"
					},
					"Children": [
						{
							"ID": "20250415130851-kn3oku7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20250415130851-kn3oku7",
								"updated": "20250415130851"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "EPT页表的工作原理"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-559zard",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-559zard",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "EPT页表存放在CPU中"
				}
			]
		},
		{
			"ID": "20250415125413-jzfooh6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-jzfooh6",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当应用程序访问内存时，将GVA交给虚拟机CPU，虚拟机CPU会通过访问虚拟机中的页表来完成GVA到GPA的转换；接着CPU通过EPT页表来实现GPA到HPA的转换"
				}
			]
		},
		{
			"ID": "20250415125413-44vzeyl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-44vzeyl",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果EPT页表没有GPA对应的HPA地址，如何解决"
				}
			]
		},
		{
			"ID": "20250415125413-k3ozzz3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-k3ozzz3",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果HPA为空，则CPU会抛出EPT Violation异常，触发一个vm exit让VMM来处理，此时VMM会根据GPA地址将其映射到对应的HVA地址，然后通过物理页表找到此HVA地址对应的HPA（如果没有HPA则为HVA分配对应的HPA），最后再更新EPT表项"
				}
			]
		},
		{
			"ID": "20250415125413-9t6s989",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-9t6s989",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果EPT页表中没有GPA地址，如何解决？"
				}
			]
		},
		{
			"ID": "20250415125413-09npwx4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-09npwx4",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果GPA地址为空（即缺页），则CPU产生缺页异常，发生缺页中断（如果是软件实现方式，则会产生vm exit）但是硬件实现方式下，并不会产生VM-exit，而是交给虚拟机内核的中断处理程序处理；在中断处理程序中会产生EXIT"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeText",
							"Data": "_"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "REASON"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeText",
							"Data": "_"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "EPT"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeText",
							"Data": "_"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "VIOLATION，虚拟机退出，VMM截获到该异常后，为虚拟机分配新的物理地址HPA，并建立新的GPA到HPA的映射关系，保存到EPT中，这样在下一次访问的时候就可以完成GPA到HPA的转换"
				}
			]
		},
		{
			"ID": "20250415125413-4lzyezc",
			"Type": "NodeThematicBreak",
			"Properties": {
				"id": "20250415125413-4lzyezc",
				"updated": "20250415125413"
			}
		},
		{
			"ID": "20250415125413-21awzcn",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20250415125413-21awzcn",
				"updated": "20250415125824"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "3. 内存虚拟化-内存超分配"
				}
			]
		},
		{
			"ID": "20250415125413-pmgddui",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-pmgddui",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 虚拟机内存和物理机内存之间并不是一一对应的，物理机可以通过内存超分配来超额分配内存给虚拟机"
				}
			]
		},
		{
			"ID": "20250415125413-1m3xxen",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-1m3xxen",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 内存超分配实现分配给虚拟机的内存总数大于实际可用的物理内存总数"
				}
			]
		},
		{
			"ID": "20250415125413-nksw9ee",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-nksw9ee",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "实现内存超分配主要通过内存复用技术实现的"
				}
			]
		},
		{
			"ID": "20250415125413-516131l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-516131l",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 而内存复用通过内存共享、内存置换、内存气泡三大技术来对内存进行分时复用，实现内存超分配"
				}
			]
		},
		{
			"ID": "20250415125413-dqiax8h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-dqiax8h",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " 内存复用"
				},
				{
					"Type": "NodeBackslash",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeText",
							"Data": "="
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "共享，气泡，置换共同作用"
				}
			]
		},
		{
			"ID": "20250415125413-pp6g193",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-pp6g193",
				"updated": "20250415125622"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "内存共享"
				}
			]
		},
		{
			"ID": "20250415125413-m50ari2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-m50ari2",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://i-blog.csdnimg.cn/blog_migrate/617b1fb76c481f25e99b476594dad5b9.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20250415125413-9xirbe5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-9xirbe5",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虚拟机之间共享同一物理内存空间（蓝色部分），并且该共享的物理内存为只读权限（多个虚拟机内存中保存的多份相同数据，在物理内存中只保留一份数据）"
				}
			]
		},
		{
			"ID": "20250415125413-uzffjxd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20250415125413-uzffjxd",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当某个虚拟机需要写入数据到共享内存空间时，此时就通过写时复制技术，另开辟一块内存空间使用，并修改映射表"
				}
			]
		},
		{
			"ID": "20250415125413-v0r1hvi",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-v0r1hvi",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "内存置换"
				}
			]
		},
		{
			"ID": "20250415125413-vy4f9ox",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20250415125413-vy4f9ox",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20250415125413-hwjxw7x",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-hwjxw7x",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://i-blog.csdnimg.cn/blog_migrate/595d0572290795de79c1d9e3a01586ae.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				},
				{
					"ID": "20250415125413-0nfzpdl",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-0nfzpdl",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "虚拟机长时间未访问的内存内容置换放到硬盘中，并建立映射表，释放内存"
						}
					]
				},
				{
					"ID": "20250415125413-iay7h90",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-iay7h90",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "当虚拟机再次访问该内存时再置换回来"
						}
					]
				}
			]
		},
		{
			"ID": "20250415125413-7tkwvn3",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20250415125413-7tkwvn3",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "内存气泡"
				}
			]
		},
		{
			"ID": "20250415125413-qq57c0n",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20250415125413-qq57c0n",
				"updated": "20250415125413"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20250415125413-kf8wxvq",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-kf8wxvq",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "将较为空间的虚拟机内存释放给内存使用率较高的虚拟机（即：把虚拟机2的空闲内存分给虚拟机1使用）；内存的回收和分配为系统动态执行，虚拟机上的应用无感知"
						}
					]
				},
				{
					"ID": "20250415125413-fqw5vsc",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-fqw5vsc",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "提升了内存利用率；不过需要保证所有虚拟机正在使用的内存总量不能超过物理机的物理内存总量"
						}
					]
				},
				{
					"ID": "20250415125413-l1m08v1",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20250415125413-l1m08v1",
						"updated": "20250415125413"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://i-blog.csdnimg.cn/blog_migrate/d87db728d3f0fb5e8b6f3102851e925a.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				}
			]
		}
	]
}